# Algorithms

 <br>

# 1.Sorting

- ## [Selection](#Selection-Sort)
- ## [Insertion](#Insertion-Sort)
- ## [Shell](#Shell-Sort)

---

## Selection Sort

`최소값`을 가지고 정렬한다.<br>

1. 0~n까지 요소 중 최소값을 찾고 0번째에 넣는다
2. 1~n까지 요소 중 최소값을 찾고 1번쨰에 넣는다
3. 배열이 다 할 때까지 반복한다.

## Insertion Sort

`그룹`을 만들어 그룹 내에서 정렬한다<br>
그룹은 갈수록 커지며 그룹 내의 비교 교환은 인자 내의 가장 큰 인자부터 구현하였다.<br>

`[ 8 5 6 2 4 ]` 라고 가정하자

1. `[0 , 1]` 인자로 그룹을 만들어 2개의 값을 비교하여 정렬한다.

   - [ `8` `5` 6 2 4 ] -> [ `5` `8` 6 2 4 ]

2. `[0 , 2]` 0~2까지의 인자로 그룹을 만들어 비교

   - [ `5` `8` `6` 2 4 ] -> [ `5` `6` `8` 2 4 ]

3. `[0 , 3]` 0~3까지의 인자로 그룹을 만들어 비교
   - [ `5 6 8 2` 4 ] -> [ `5 6 2 8 ` 4 ] -> [ `5 2 6 8 ` 4 ] -> [ `2 5 6 8 ` 4 ]

<br>

## Shell Sort

삽입정렬의 친구. 삽입정렬은 바로 앞의 원소와 비교했기 때문에 가장 작은 원소가 마지막에 있을 경우 지연된다.<br>

h개만큼 떨어진 원소들과 비교 후 정렬한다. 삽입정렬에서 간격이 생긴 정렬이라고 생각하자.<br>

간격은 h = 3\*h + 1로 일반적으로 지정된다. <br><br>

1. h를 구하고 h는 가장 큰 값을 기준으로 정렬한다. ( 1 4 13 53 이었다면 53부터)

2. 교환할 인자들이 h만큼 떨어져 있는 것 빼곤 삽입정렬과 같다.

3. `부분배열`을 형성하고 부분배열은 처음인자와 h만큼 떨어져있는 원소들의 집합이다.

4. 부분배열 내에서의 비교는 마지막 원소부터 처음원소까지 비교한다.

<br>

- Shell sort Feedback
  - Shell sorting 만드는데 하루하고 2시간이 더 걸렸다.
  - 초기단계
    - NullPoint/IndexboundOut이 나를 괴롭혔다
    - 코드를 작성하다 보니 삽입정렬이 뭔지 헷갈리게 되었다
    - 결국, 나만의 새로운 소팅방식을 만들게됨.
  - 중반단계
    - 나의 잘못된 점을 파악하고 코드를 다시 짜기로 결정.
    - 부분배열을 만들어 그 배열 내에서 비교를 해야한다는 걸 깨달음
  - 후반단계
    - 부분배열을 만드는 for문
    - 배열내 마지막 인자부터 시작하는 변수를 뭐와 관련시킬지
    - 부분배열 내에서는 마지막 인자부터 처음인자까지 모두 비교하면서 진행하는 for문
    - 위의 3가지가 Shell sort의 제일 큰 장애물 부분이었다.
  - 교훈 : 생각을 한 다음에 Eclips를 키자(손부터 먼저 움직였기 때문에 더욱 헤맸던 걸로 판단한다)
